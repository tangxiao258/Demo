## 登录拦截逻辑
### 第一步：路由拦截
首先在定义路由的时候就需要多添加一个自定义字段`requireAuth`,用于判断该路由的访问是否需要登录。如果用户已经登录，则顺利进入路由，否则就进入登录页面。
```js
const routes = [
    {
        path: '/',
        name: '/',
        component: Index
    },
    {
        path: '/responsitory',
        name: 'responsitory',
        meta: {
            requireAuth: true
        },
        component: Responsitory
    },
    {
        path: '/login',
        name: 'login',
        component: Login
    }
]
```
定义完路由后，我们主要是利用`vue-router`提供的钩子函数`beforeEach()`对路由进行判断。
```js
router.beforeEach((to, form, next) =>{
    if(to.meta.requireAuth){  // 判断该路由是否需要登录权限
        if(store.state.token){  // 通过vuex state获取当前的token是否存在
            next()
        }else{
            next({
                path: '/login',
                query: {redirect: to.fullPath}  // 将跳转的路由path作为实参，登录成功后跳转到该路由
            })
        }
    }
})
```
每个钩子方法接收三个参数：
- to:Route:即将要进入的目标 路由对象
- from:Route:当前导航正要离开的路由
- next:Function:一定要调用该方法来resolve这个钩子。执行效果依赖next方法调用的参数。
    - next():进行管道中的一个钩子。如果全部钩子执行完了，则导航的状态就是confirmed（确认的）
    - next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。
    - next('/') 或者 next({ path: '/' }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。

**确保要调用next方法，否则钩子就不会被resolved**
其中，`to.meta`中使我们自定义的数据，其中就包括我们刚刚定义的`requireAuth`字段。通过这个字段来判断该路由是否需要登录权限。需要的话，同事当前应用不存在token，则跳转到登录页面进行登录。登录成功后跳转到目标路由。

登录拦截到这里就结束了吗？并没有，这种方式只是简单地前端路由控制，并不能真正阻止用户访问需要登录权限的路由。还有一种情况便是：当前token失效了，但是token依然保存在本地。这时候你去访问需要登录权限的路由时，实际上应该让用户重新登录。这时候就需要结合http拦截器+后端接口返回的http状态码来判断。


### 第二步：拦截器
要想统一处理所有http请求和相应，就得用上axios的拦截器。通过配置`http response inteceptor`，当后端接口返回`401 Unauthorized(未授权)`，让用户重新登录。
```js
// http request 拦截器
axios.interceptor.request.use(
    config =>{
        if(store.state.token){  // 判断是否存在token，如果存在的话，则每个http header都加上token
            config.headers.Authorization = `token ${store.state.token}`
        }
        return config
    },
    err =>{
        return Promise.reject(err)
    }
)

// http response 拦截器
axios.interceptors.response.use(
    response =>{
        return response;
    },
    error => {
        if(error.response){
            switch(error.reponse.status){
                case 401:
                // 返回401 清楚token信息并跳转到登录页
                store.commit(types.LOGOUT)
                
                // 只有在当前路由不是登陆页面才跳转
                router.currentRoute.path !== 'login' && router.replace({
                    path: 'login',
                    query:　{redirect:　router.currentRoute.path}
                })
            }
        }
        return Promise.reject(error.response.data)
    }
)
```
通过上面这两步，就可以在前端实现登录拦截了。`登出`功能也就很简单，只需要把当前token清楚，再跳转到首页即可。
